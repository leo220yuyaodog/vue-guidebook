(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{185:function(t,e,a){t.exports=a.p+"assets/img/vue-lifecycle.ee45a99a.jpg"},186:function(t,e,a){t.exports=a.p+"assets/img/lifecycle-initialize.fa60e4eb.jpg"},187:function(t,e,a){t.exports=a.p+"assets/img/lifecycle-compile.061e9078.jpg"},188:function(t,e,a){t.exports=a.p+"assets/img/lifecycle-reactive.63287300.jpg"},189:function(t,e,a){t.exports=a.p+"assets/img/lifecycle-dep.562b4bb9.jpg"},220:function(t,e,a){"use strict";a.r(e);var s=a(0),r=Object(s.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生命周期","aria-hidden":"true"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),s("p",[t._v("生命周期并非指 Vue 中的生命周期钩子，而是指 Vue 内部从初始化到挂载 DOM 的完整流程。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(185),alt:"Vue Lifecycle"}})]),t._v(" "),s("h2",{attrs:{id:"初始化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#初始化","aria-hidden":"true"}},[t._v("#")]),t._v(" 初始化")]),t._v(" "),s("p",[s("img",{attrs:{src:a(186),alt:"initialize"}})]),t._v(" "),s("p",[t._v("在 "),s("code",[t._v("new Vue()")]),t._v(" 之后。Vue 会调用挂载在其原型上的 "),s("code",[t._v("_init")]),t._v(" 函数进行初始化，也就是这里的 init 过程，它会初始化生命周期、事件、props、methods、data、computed 与 watch 等。其中最重要的是通过 "),s("code",[t._v("Object.defineProperty")]),t._v(" 设置 "),s("code",[t._v("setter")]),t._v(" 与 "),s("code",[t._v("getter")]),t._v(" 函数，用来实现"),s("span",{staticStyle:{color:"red","font-weight":"bold"}},[t._v("响应式")]),t._v("以及"),s("span",{staticStyle:{color:"red","font-weight":"bold"}},[t._v("依赖收集")]),t._v("。")]),t._v(" "),s("p",[t._v("初始化后会调用 "),s("code",[t._v("$mount")]),t._v(" 进行挂载组件，如果是运行时编译（Runtime with Compiler），即不存在 render function 但是存在 template 的情况，则需要进行"),s("span",{staticStyle:{color:"red","font-weight":"bold"}},[t._v("编译")]),t._v("步骤。")]),t._v(" "),s("h2",{attrs:{id:"编译"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译","aria-hidden":"true"}},[t._v("#")]),t._v(" 编译")]),t._v(" "),s("p",[t._v("编译（Compiler）可以分成 Parse、Optimize 与 Generate 三个阶段，最终需要得到 render function。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(187),alt:"Compile"}})]),t._v(" "),s("h3",{attrs:{id:"parse"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#parse","aria-hidden":"true"}},[t._v("#")]),t._v(" Parse")]),t._v(" "),s("p",[t._v("Parse 会用正则等方式解析 template 模版中的指令、class、style 等数据，形成 AST。")]),t._v(" "),s("h3",{attrs:{id:"optimize"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#optimize","aria-hidden":"true"}},[t._v("#")]),t._v(" Optimize")]),t._v(" "),s("p",[t._v("Optimize 的主要作用是标记 static 静态节点，这时 Vue 在编译过程中的优化，后面当 update 更新界面时，会有一个 patch 的过程，diff 算法会直接跳过静态节点，从而减少了比较的过程，优化了 patch 的性能。")]),t._v(" "),s("h3",{attrs:{id:"generate"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#generate","aria-hidden":"true"}},[t._v("#")]),t._v(" Generate")]),t._v(" "),s("p",[t._v("Generate 是将 AST 转化成 render function 字符串的过程，得到结果是 render 的字符串以及 staticRenderFns 字符串。")]),t._v(" "),s("p",[t._v("在经历过 Parse、Optimize 与 Generate 这三个阶段之后，组件中就会存在渲染 VNode 所需的 render function 了。")]),t._v(" "),s("h2",{attrs:{id:"响应式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#响应式","aria-hidden":"true"}},[t._v("#")]),t._v(" 响应式")]),t._v(" "),s("p",[s("img",{attrs:{src:a(188),alt:"Reactive"}})]),t._v(" "),s("p",[t._v("在 init 过程中通过 Object.defineProperty 对响应式数据的 getter 和 setter 进行绑定，它使得当被设置的对象被读取的时候会执行 getter 函数，而在当被赋值的时候会执行 setter 函数。")]),t._v(" "),s("p",[t._v("当 render function 被渲染的时候，因为会读取所需对象的值，所以会触发 getter 函数进行"),s("span",{staticStyle:{color:"red","font-weight":"bold"}},[t._v("依赖收集")]),t._v("，依赖收集的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(189),alt:"Lifecycle Dep"}})]),t._v(" "),s("p",[t._v("在修改对象的值时候，会触发 setter，setter 通知之前依赖收集得到的 Dep 中的每个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 update 来更新视图，当然这中间还有一个 patch 过程以及使用队列来异步更新的策略。")]),t._v(" "),s("h2",{attrs:{id:"virtual-dom"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom","aria-hidden":"true"}},[t._v("#")]),t._v(" Virtual DOM")]),t._v(" "),s("p",[t._v("render function 会被转化成 VNode 节点。Virtual DOM 其实就是一棵以 JavaScript 对象（VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  tag"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'div'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 说明是 div 标签 */")]),t._v("\n  children"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 存放该标签的子节点 */")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      tag"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'a'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 说明是 a 标签 */")]),t._v("\n      text"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'click me'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 标签内容 */")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("渲染后可以得到：")]),t._v(" "),s("div",{staticClass:"language-html extra-class"},[s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("Click me"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),s("p",[t._v("实际上节点有更多的属性来标识节点，例如 isStatic（表示是否为静态节点）、isComment（表示是否为注释节点）等。")]),t._v(" "),s("h2",{attrs:{id:"更新视图"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#更新视图","aria-hidden":"true"}},[t._v("#")]),t._v(" 更新视图")]),t._v(" "),s("p",[t._v("在修改对象值时，会通过 "),s("code",[t._v("setter => Watcher => update")]),t._v(" 的流程来修改对应的视图，那么最终是如何更新视图呢？")]),t._v(" "),s("p",[t._v("当数据变化后，执行 render function 就可以得到一个新的 VNode 节点，我们如果想要得到新的视图，最简单粗暴的方法就是直接解析这个新的 VNode，然后用 "),s("code",[t._v("innerHTML")]),t._v(" 直接全部渲染到真实 DOM 中。但是其实我们只对其中的一小块内容进行了修改，这样做似乎会消耗大量成本。")]),t._v(" "),s("p",[t._v("那么我们为什么不能只修改那些「改变了的地方」呢？")]),t._v(" "),s("p",[t._v("通过新的 VNode 与旧的 VNode 传入 patch 进行比较，经过 diff 算法得出它们的"),s("span",{staticStyle:{color:"red","font-weight":"bold"}},[t._v("差异")]),t._v("。最后我们只需要将这些"),s("strong",[t._v("差异")]),t._v("的对应 DOM 进行修改即可。")]),t._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("p",[t._v("Vue 生命周期总结：")]),t._v(" "),s("ol",[s("li",[t._v("首先，在实例化的过程中，把普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defaineProperty 把这些属性全部转为 getter 和 setter。")]),t._v(" "),s("li",[t._v("Dep 是依赖收集器。data 下的每个属性都有一个唯一的 Dep 对象，在 get 中收集仅针对该属性的依赖，然后在 set 方法中触发所有收集的依赖。")]),t._v(" "),s("li",[t._v("在 Watcher 中对表达式求值，从而触发数据的 get。在求值之前将当前 Watch 实例设置到全局，使用 "),s("code",[t._v("pushTarget(this)")]),t._v(" 方法。")]),t._v(" "),s("li",[t._v("在 get 中收集依赖，"),s("code",[t._v("this.subs.push(sub)")]),t._v(" 和 set 的时候触发回调 Dep.notify。")]),t._v(" "),s("li",[t._v("Compile 中首先将 template 或 el 编译成 render 函数，render 函数返回一个虚拟 DOM 对象（将模版转为 render 函数的时候，实际是先生成的抽象语法树 AST，再将抽象语法树转成的 render 函数）")]),t._v(" "),s("li",[t._v("当 "),s("code",[t._v("vm._render")]),t._v(" 执行的时候，所依赖的变量就会被求值，并被收集为依赖。按照 Vue 中 "),s("code",[t._v("watch.js")]),t._v(" 的逻辑，当依赖的变量有变化时不仅仅回调函数被执行，实际上还要重新求值，即还要执行一遍。")]),t._v(" "),s("li",[t._v("如果还没有 preVnode 说明是首次渲染，直接创建真实 DOM。如果已经有了 prevVnode 说明不是首次渲染，那么就采用 patch 算法进行必要的 DOM 操作。这就是 Vue 更新 DOM 的逻辑。")])]),t._v(" "),s("hr"),t._v(" "),s("p",[s("strong",[t._v("参考资料：")])]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://github.com/answershuto/learnVue/blob/master/docs/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.MarkDown",target:"_blank",rel:"noopener noreferrer"}},[t._v("📝 Vue 的响应式原理"),s("OutboundLink")],1)])])])},[],!1,null,null,null);e.default=r.exports}}]);