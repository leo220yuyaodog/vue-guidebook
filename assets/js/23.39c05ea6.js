(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{221:function(e,t,r){"use strict";r.r(t);var n=r(0),v=Object(n.a)({},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"异步更新队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#异步更新队列","aria-hidden":"true"}},[e._v("#")]),e._v(" 异步更新队列")]),e._v(" "),r("p",[e._v("Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个事件循环 tick 中，Vue 刷新队列并执行实际（已去重）工作。Vue 在内部对异步队列尝试使用原生的 "),r("code",[e._v("Promise.then")]),e._v("、"),r("code",[e._v("MutationObserver")]),e._v(" 和 "),r("code",[e._v("setImmediate")]),e._v("，如果执行环境不支持，则会采用 "),r("code",[e._v("setTimeout(fn, 0)")]),e._v(" 代替。")]),e._v(" "),r("p",[e._v("例如，当你设置 "),r("code",[e._v("vm.foo = 'new value'")]),e._v("，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环 tick 中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue 通常鼓励开发人员使用"),r("strong",[e._v("数据驱动")]),e._v("的方式思考，避免直接接触 DOM，但是有时我们必须这样做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 "),r("code",[e._v("Vue.nextTick(callback)")]),e._v("。这样回调函数将在 DOM 更新完成后被调用。")]),e._v(" "),r("p",[e._v("Vue 在哪里使用到了宏任务和微任务\nVue 为什么需要宏任务和微任务")]),e._v(" "),r("hr"),e._v(" "),r("p",[r("strong",[e._v("参考资料：")])]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/tL7mk5yDqC0YcHXTtL9hNw",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue.nextTick() 浅析"),r("OutboundLink")],1)])])])},[],!1,null,null,null);t.default=v.exports}}]);