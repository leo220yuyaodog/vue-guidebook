(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{184:function(t,e,r){t.exports=r.p+"assets/img/lifecycle.6f2c97f0.png"},208:function(t,e,r){"use strict";r.r(e);var a=r(0),v=Object(a.a)({},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"生命周期钩子函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期钩子函数","aria-hidden":"true"}},[t._v("#")]),t._v(" 生命周期钩子函数")]),t._v(" "),a("p",[a("strong",[t._v("生命周期")]),t._v("：就是从一个组件或实例开始初始化、创建实例到该实例被销毁的过程。")]),t._v(" "),a("p",[t._v("在这个过程中需要设置"),a("strong",[t._v("数据监听")]),t._v("、"),a("strong",[t._v("编译模版")]),t._v("、"),a("strong",[t._v("挂载实例")]),t._v("到 DOM 并在数据变化时"),a("strong",[t._v("更新")]),t._v(" DOM 等。")]),t._v(" "),a("p",[t._v("同时，在这个过程中 Vue 给开发者提供了很多方法，也就是所说的生命周期钩子函数。")]),t._v(" "),a("p",[t._v("由此，真正的生命周期是一个流程，而不是单单的几个钩子函数，钩子函数只是用来在流程的不同阶段帮助我们做更多的事情。")]),t._v(" "),a("p",[a("img",{attrs:{src:r(184),alt:"生命周期函数"}})]),t._v(" "),a("h2",{attrs:{id:"create"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#create","aria-hidden":"true"}},[t._v("#")]),t._v(" create")]),t._v(" "),a("p",[a("strong",[t._v("实例化 Vue 阶段。")])]),t._v(" "),a("p",[t._v("在谈到 Vue 的生命周期的时候，我们首先需要创建一个实例，也就是在 new Vue() 对象过程中，首先执行了 init 函数（init 是 Vue 构造函数内部默认执行的），为当前实例完成基础配置，包括定义 Vue 构造函数上的静态方法以及相关的生命周期钩子函数。")]),t._v(" "),a("p",[t._v("在 beforeCreate 和 created 的钩子调用是在 "),a("code",[t._v("initState")]),t._v(" 前后，该函数作用是初始化 props、data、methods、computed、watch 等属性，因此 beforeCreated 的钩子函数也就无法获取到 props 和 data 等定义的值，也不能调用 methods 中定义的函数。")]),t._v(" "),a("p",[t._v("在这俩个钩子函数执行的时候，并没有渲染 DOM，所以我们也不能够访问 DOM，一般来说，如果组件在加载的时候需要和后端有交互，放在这俩个钩子函数执行都可以，如果是需要访问 props、data 等数据的话，就需要使用 created 钩子函数。")]),t._v(" "),a("p",[t._v("完成配置对象的初始化后，会调用 "),a("span",{staticStyle:{color:"red","font-weight":"bold"}},[t._v("created")]),t._v(" 生命周期钩子函数，这个时候 "),a("strong",[t._v("Vue 对象实例化完毕")]),t._v("，DOM 树依旧未生成，页面还是一片空白，但是，实例已完成以下配置："),a("strong",[t._v("数据观察")]),t._v("（data observer）、"),a("strong",[t._v("属性和方法运算")]),t._v("以及 "),a("strong",[t._v("watch/event 事件回调")]),t._v("。此时，该钩子函数适合"),a("strong",[t._v("处理网络请求")]),t._v("等逻辑操作。")]),t._v(" "),a("p",[t._v("如果在实例化配置中存在 "),a("code",[t._v("el")]),t._v(" 选项，实例将立即进入编译阶段，否则，则停止编译，也就意味着停止了生命周期，知道在该 Vue 实例上调用 "),a("code",[t._v("vm.$mount(el)")]),t._v("。")]),t._v(" "),a("p",[t._v("编译阶段，如果存在 render 选项，则 template 将被忽略，因为 render 渲染函数是字符串模版的代替方案。如果存在 template 选项，则会通过 compiler 编译成 render function（渲染函数），预编译是在 Webpack 等构建工具中完成的，而运行时编译则是在运行时编译的。如果既无 render 选项也无 template 选项，则查找 el 选项的 outerHTML 作为 template 并编译成 renfer function。")]),t._v(" "),a("blockquote",[a("p",[t._v("优先级：render 选项 > template 选项 > outerHTML")])]),t._v(" "),a("h2",{attrs:{id:"mount"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mount","aria-hidden":"true"}},[t._v("#")]),t._v(" mount")]),t._v(" "),a("p",[t._v("开始挂载前，会先执行钩子函数 "),a("span",{staticStyle:{color:"red","font-weight":"bold"}},[t._v("beforeMount")]),t._v("，编译 template 里的内容并在虚拟 DOM 中执行，页面上依旧没有任何展示。")]),t._v(" "),a("p",[t._v("接着，Vue 内部将给 vm 实例对象添加 "),a("code",[t._v("$el")]),t._v(" 属性，并使用编译好的 HTML 内容替换 el 选项指向的 DOM 对象或者选择对应的 HTML 标签里面的内容。当真实 DOM 挂载完毕后，执行 "),a("span",{staticStyle:{color:"red","font-weight":"bold"}},[t._v("mounted")]),t._v(" 钩子函数。此时，该钩子函数适合用于"),a("strong",[t._v("访问真实 DOM 数据坐标信息")]),t._v("。")]),t._v(" "),a("p",[t._v("created 阶段的网络请求与 mounted 请求的区别：前者页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态。")]),t._v(" "),a("h2",{attrs:{id:"update"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#update","aria-hidden":"true"}},[t._v("#")]),t._v(" update")]),t._v(" "),a("p",[t._v("当数据产生变化，会进入更新周期函数并先调用 "),a("span",{staticStyle:{color:"red","font-weight":"bold"}},[t._v("beforeUpdate")]),t._v("，这个钩子中可进一步修改 "),a("code",[t._v("$vm.data")]),t._v("，但是不会触发附加的重渲染过程。然后经过新旧对比产生新的 VirtualDOM 并进行重渲染，更新完成后将调用 updated 钩子函数。")]),t._v(" "),a("p",[t._v("当 "),a("span",{staticStyle:{color:"red","font-weight":"bold"}},[t._v("updated")]),t._v(" 钩子调用时，组件 DOM 的 data 已经更新，所以你现在可以执行依赖于 DOM 的操作。但是不要在此时修改 data，否则会再次触发 beforeUpdate、updated 这个两个钩子，导致进入死循环。")]),t._v(" "),a("h2",{attrs:{id:"destroy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#destroy","aria-hidden":"true"}},[t._v("#")]),t._v(" destroy")]),t._v(" "),a("p",[a("span",{staticStyle:{color:"red","font-weight":"bold"}},[t._v("beforeDestroy")]),t._v(" 钩子函数在实例销毁钱调用，在这步，实例仍然可用。")]),t._v(" "),a("p",[t._v("beforeDestroyed 钩子函数在 Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。")]),t._v(" "),a("h2",{attrs:{id:"activated-deactivated"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#activated-deactivated","aria-hidden":"true"}},[t._v("#")]),t._v(" activated & deactivated")]),t._v(" "),a("p",[t._v("为 keep-alive 组件定制的钩子函数。")]),t._v(" "),a("h2",{attrs:{id:"捕捉错误"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#捕捉错误","aria-hidden":"true"}},[t._v("#")]),t._v(" 捕捉错误")]),t._v(" "),a("p",[t._v("在这个过程当中，Vue 为我们提供了 renderError 方法，这个方法只有在开发的时候才会被调用，在正式打包上线过程当中，它是不会被调用的。它主要是帮助我们调试 render 里面的一些错误。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("renderError")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("h"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" err")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("h")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'div'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" err"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("stack"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("有且只有当 render 方法里面报错了，才会触发 renderError 方法。")]),t._v(" "),a("p",[t._v("所以我们主动让 render 函数报个错。")]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("生命周期钩子")]),t._v(" "),a("th",[t._v("组件状态")]),t._v(" "),a("th",[t._v("最佳实践")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("beforeCreated")]),t._v(" "),a("td",[t._v("实例初始化后，"),a("code",[t._v("this")]),t._v(" 指向创建的实例"),a("br"),t._v("但是不能访问到 data、computed、watch 和 methods 上的方法和数据")]),t._v(" "),a("td",[t._v("常用于初始化非响应式变量")])]),t._v(" "),a("tr",[a("td",[t._v("created")]),t._v(" "),a("td",[t._v("实例创建完成，可访问 data、computed、watch 和 methods 上的方法和数据"),a("br"),t._v("未挂载到 DOM，不能访问 "),a("code",[t._v("$el")]),t._v(" 属性，"),a("code",[t._v("$ref")]),t._v(" 属性内容为空数组")]),t._v(" "),a("td",[t._v("常用于简单的 AJAX 请求，页面的初始化")])]),t._v(" "),a("tr",[a("td",[t._v("beforeMount")]),t._v(" "),a("td",[t._v("在挂载开始之前被调用"),a("br"),a("code",[t._v("beforeMount")]),t._v(" 之前，会找到对应的 template，并编译成 render 函数")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("mounted")]),t._v(" "),a("td",[t._v("实例挂载到 DOM 上，此时可以通过 DOM API 获取到 DOM 节点，"),a("code",[t._v("$ref")]),t._v(" 属性可以访问")]),t._v(" "),a("td",[t._v("常用于获取 VNode 信息和操作，AJAX 请求")])]),t._v(" "),a("tr",[a("td",[t._v("beforeUpdate")]),t._v(" "),a("td",[t._v("响应式数据更新时调用，发生在 Virtual DOM 打补丁前")]),t._v(" "),a("td",[t._v("适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器")])]),t._v(" "),a("tr",[a("td",[t._v("updated")]),t._v(" "),a("td",[t._v("Virtual DOM 重新渲染和打补丁之后调用，组件 DOM 已经更新，可执行依赖于 DOM 的操作")]),t._v(" "),a("td",[t._v("避免在这个钩子函数中操作数据，可能陷入死循环")])]),t._v(" "),a("tr",[a("td",[t._v("beforeDestroy")]),t._v(" "),a("td",[t._v("实例销毁之前调用。这一步，实例仍然完全可用，"),a("code",[t._v("this")]),t._v(" 仍能获取到实例引用")]),t._v(" "),a("td",[t._v("常用于销毁定时器、解绑全局事件、销毁插件对象等操作")])]),t._v(" "),a("tr",[a("td",[t._v("destroyed")]),t._v(" "),a("td",[t._v("实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁")]),t._v(" "),a("td")])])]),t._v(" "),a("hr"),t._v(" "),a("p",[a("strong",[t._v("参考资料：")])]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://juejin.im/post/5b41bdef6fb9a04fe63765f1#heading-17",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue 的钩子函数"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.im/post/5ad10800f265da23826e681e",target:"_blank",rel:"noopener noreferrer"}},[t._v("如果解释 Vue 生命周期才能令面试官满意"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.cnblogs.com/padding1015/p/9159381.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("生命周期二次学习与理解"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.im/post/5d1b464a51882579d824af5b",target:"_blank",rel:"noopener noreferrer"}},[t._v("从源码解读 Vue 生命周期，让面试官对你刮目相看"),a("OutboundLink")],1)])])])},[],!1,null,null,null);e.default=v.exports}}]);